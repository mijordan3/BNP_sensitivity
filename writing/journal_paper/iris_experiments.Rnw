%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Do not edit the TeX file your work
% will be overwritten.  Edit the RnW
% file instead.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
  <<setup, include=FALSE, cache=FALSE>>=
    knitr_debug <- FALSE # Set to true to see error output
    simple_cache <- FALSE # Set to true to cache knitr output for this analysis.
    source("R_scripts/initialize.R", echo=FALSE)
    source("R_scripts/plotting_utils.R")
@
      
      
      
<<iris_fit_cap>>=
iris_fit_cap <- paste("The iris fit.  ")
SetImageSize(aspect_ratio = base_aspect_ratio, 
             image_width = base_image_width * 0.5)
@
<<iris_fit, cache=simple_cache, fig.show='hold', fig.cap=iris_fit_cap>>=

iris_fit_file <- np$load('./R_scripts/iris/data/iris_fit.npz')

##################
# plot iris data (has already been transformed into PC space)
##################
iris_obs <- as.data.frame(iris_fit_file['pc_iris_obs']) %>%
  mutate(est_z = iris_fit_file['cluster_memberships']) %>%
  mutate(est_z = as.factor(est_z))

# colors: this is 3-class Set2 from colorbrewer
# didn't just use scale_color_brewer bc we will manually label 
# the covariances with these colors, later
colors <- c('#66c2a5','#fc8d62','#8da0cb')
p <- ggplot() + 
  geom_point(data = iris_obs, aes(x = V1, y = V2, color = est_z)) + 
  scale_color_manual(values = colors) 

##################
# plot centroids / covariances
##################
# these are are also already in pc space
est_centroids <- iris_fit_file['pc_centroids']
est_covariances <- iris_fit_file['pc_cov']

unique_clusters = unique(iris_fit_file['cluster_memberships'])
n_unique_clusters = length(unique_clusters)
for(i in 1:n_unique_clusters){
  
  # python was 0 indexed ...
  k = unique_clusters[i] + 1
  
  centroids_k <- est_centroids[k, ]
  eigs_k <- eigen(est_covariances[k, , ],
                  symmetric = TRUE)
  
  # need aes_string when adding plots in a for-loop?
  p <- p + geom_ellipse(aes_string(x0 = centroids_k[1],
                          y0 = centroids_k[2], 
                          a = sqrt(eigs_k$values[1]) * 3,
                          b = sqrt(eigs_k$values[2]) * 3,
                          angle = atan(eigs_k$vectors[2, 1] / 
                                       eigs_k$vectors[1, 1])), 
                        color = colors[i])
}

p + 
  xlab('PC1') + 
  ylab('PC2') + 
  theme(legend.position = 'none')


@


<<iris_alpha_sens_cap>>=
      iris_alpha_sens_cap <- paste(
        "iris alpha sensitivity ")
    SetImageSize(aspect_ratio = 0.5 * base_aspect_ratio)
@
<<iris_alpha_sens, cache=simple_cache, fig.show='hold', fig.cap=iris_alpha_sens_cap>>=
source("R_scripts/iris/iris_alpha_sens.R", echo=knitr_debug, print.eval=TRUE)
@


<<iris_fsens_cap>>=
      iris_fsens_cap <- paste(
        "iris functional sensitivity ")
    SetImageSize(aspect_ratio = 1.4 * base_aspect_ratio)
@
<<iris_fsens, cache=simple_cache, fig.show='hold', fig.cap=iris_fsens_cap>>=

source("R_scripts/iris/iris_func_sens.R", echo=knitr_debug, print.eval=TRUE)

include_graphics('./R_scripts/iris/figures_tmp/iris_func_pert.png')
@


