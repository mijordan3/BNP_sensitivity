%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Do not edit the TeX file your work
% will be overwritten.  Edit the RnW
% file instead.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<setup, include=FALSE, cache=FALSE>>=
knitr_debug <- FALSE # Set to true to see error output
simple_cache <- TRUE # Set to true to cache knitr output for this analysis.
source("R_scripts/initialize.R", echo=FALSE)
source("R_scripts/plotting_utils.R")
source("R_scripts/mice/mice_plotting_utils.R")

# load data
load('./R_scripts/data_processed/mice.RData')
@

We consider the problem of clustering time-course gene expression data. 
While thousands genes might be measured in a given genomics experiment, 
many genes may exhibit similar expression patterns.  
Clustering genes is one way to reduce the dimensionality of a complex data set 
and faciliates scientific interpretations. 
Often, such dimensionality reduction is used for exploratory analysis and
is a first step before further downstream analyses. 
It is important, therefore, to acertain the stability of the 
discovered clusters. 
 
We study a publicly available data set of mice gene expression
\citep{shoemaker:2015:ultrasensitive}.
Mice were infected with different influenza viruses, and gene expression
was assessed at 14 time points after infection.
Our analysis focuses on mice treated with the ``A/California/04/2009'' strain. 
We normalize the data as described in
\citet{shoemaker:2015:ultrasensitive} and then apply the differential
analysis tool EDGE \citep{Storey:2005:significance} to rank the genes from most to least significantly differentially expressed. 
We run our analysis below on the top $\ngenes = 1000$ genes.

\subsubsection*{The model}


Each gene consists of $\ntimepoints = 42$ measurements of expression: three replicates at 14 unique timepoints.
The timepoints are unevenly spaced, with more frequent observations at the beginning. 
We model the first 11 timepoints with cubic B-splines with 7 degrees of freedom.
For the last three timepoints, $t = 72, 120, 168$ hours,
we use indicator functions. 
That is, if $\tilde X$ is the matrix where each column is a B-spline basis vector evaluated at the $\ntimepoints$ timepoints, we append to $\tilde X$ three additional columns where each column is 1 if $t = 72, 120,$ or 168, repectively, and 0 otherwise. 
Call the full design matrix $X$. 
Without the indicator columns, the matrix $\tilde X^T \tilde X$ is nearly singular, because the later timepoints are more spread out. 
See \figref{example_genes} for an example gene and the B-spline basis. 

Let $\x_\n$ be the vector of observations $(\x_{\n 1}, ..., \x_{\n \ntimepoints})^T$.
Each cluster is characterized by a vector of regression coefficients 
$\beta_k$ and a variance $\tau^{-1}_k$; let $\theta_k = (\beta_k, \tau_k)$. 
The distribution of the data arising from cluster $k$ is 
\begin{align*}
p(\x_\n | \theta_k, b_{n}) = 
\normdist{\x_\n | X\beta_k + b_{n},
\tau^{-2}I_{\ntimepoints \times \ntimepoints}},
\end{align*}
where $b_{n}$ is a gene-specific additive offset. 

The joint distribution similar to~\eqref{bnp_model}, except with the addition of the additive offset: 
\begin{align*}
\MoveEqLeft
\logp(\x, \theta, \z, \nu) ={}
\nonumber\\&
    \sum_{n=1}^N \sum_{k=1}^{\kmax}
        \z_{\n\k} \left(
            \logp(\x_n \vert \theta_\k, b_n) + \logp(b_n) + \log \pi_\k
        \right) +
    \sum_{k=1}^{\kmax} \left(
        \log \pstick(\nuk) + \logp(\theta_\k) 
    \right).
\end{align*}
The prior on the shift $\logp(b_n)$ 


%
<<example_genes_cap, cache=FALSE>>=
example_genes_cap <- paste(
    "(Left) An example gene and its expression over time.
     (Right) The cubic B-spline with 7 degrees of freedom. ")
SetImageSize(aspect_ratio = 0.5 * base_aspect_ratio)
@
<<example_genes, cache=simple_cache, fig.show='hold', fig.cap=example_genes_cap>>=
source("R_scripts/mice/example_gene.R", echo=knitr_debug, print.eval=TRUE)
@
%





<<gene_centroids_cap, cache=FALSE>>=
gene_centroids_cap <- paste(
    "In blue, inferred centroids from the twelve most occupied clusters.
    In grey, gene expressions averaged over replicates and
    shifted by their inferred intercepts. ")
SetImageSize(aspect_ratio=base_aspect_ratio * 0.8)
@
<<gene_centroids, cache=simple_cache, fig.show='hold', fig.cap=gene_centroids_cap>>=
source("R_scripts/mice/example_centroids.R", echo=knitr_debug, print.eval=TRUE)
@






<<gene_initial_coclustering_cap, cache=FALSE>>=
gene_initial_coclustering_cap <- paste(
    "The inferred co-clustering of gene expressions at $\\alpha = 3.$ ")
SetImageSize(aspect_ratio=base_aspect_ratio * 0.85,
             image_width = 0.6)
@
<<gene_initial_coclustering, cache=simple_cache, fig.show='hold', fig.cap=gene_initial_coclustering_cap>>=
p <- plot_coclustering(coclust_init) +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.text = element_text(size = axis_ticksize))
p
@









<<gene_alpha_coclustering_cap, cache=FALSE>>=
gene_alpha_coclustering_cap <-
    paste0("Changes in the co-clustering matrix at alpha = 1 (top row)
     and alpha = 11 (bottom row),
     relative to the co-clustering matrix at alpha = 3.
     The left column plots differences predicted by the
     linear approximation against differences from a model refit.
     Each point represents an entry of the co-coclustering matrix.
     The middle and right columns display
     changes in the co-clustering matrix as obtained by the
     linear approximation and the model refit, respectively.")

SetImageSize(aspect_ratio=base_aspect_ratio)
@
<<gene_alpha_coclustering, cache=simple_cache, fig.show='hold', fig.cap=gene_alpha_coclustering_cap>>=
source("R_scripts/mice/alpha_coclustering_matrix.R", echo=knitr_debug, print.eval=TRUE)
@




<<gene_alpha_coclustering_infl_cap, cache=FALSE>>=
gene_alpha_coclustering_infl_cap <- paste(
    "The influence function of $g_{ev}$, the sum of the eigenvalues of the coclustering Laplacian matrix. ")
SetImageSize(aspect_ratio=base_aspect_ratio * 0.4)
@
<<gene_alpha_coclustering_influence, cache=simple_cache, fig.show='hold', fig.cap=gene_alpha_coclustering_infl_cap>>=
source("R_scripts/mice/coclustering_influence.R",
       echo=knitr_debug, print.eval=TRUE)
@




<<gene_fpert_coclustering_cap, cache=FALSE>>=
gene_fpert_coclustering_cap <- paste(
    "Effect on the co-clustering matrix after a functional perturbation.
     log-phi (top left, in grey) is set to a Gaussian p.d.f. centered at mu = -4.2, and scaled to have L-infinity norm equal to two.
    The chosen log-phi roughly corresponds to a positive bump in the influence function of $g_{ev}$.")
SetImageSize(aspect_ratio=base_aspect_ratio)
@
<<gene_fpert_coclustering, cache=simple_cache, fig.show='hold', fig.cap=gene_fpert_coclustering_cap>>=
source("R_scripts/mice/fpert_coclustering_matrix.R",  echo=knitr_debug, print.eval=TRUE)

@


<<alpha_pert_logphi_cap, cache=FALSE>>=
alpha_pert_logphi_cap <- paste(
    "The log multiplicative perturbation $\\log \\phi$ corresponding to decreasing the $\\alpha$ parameter by five (left) or increasing the $\\alpha$ parameter by five (right). ")
SetImageSize(aspect_ratio=base_aspect_ratio * 0.5)
@
<<alpha_pert_logphi, cache=simple_cache, fig.show='hold', fig.cap=alpha_pert_logphi_cap>>=
source("R_scripts/mice/alpha_log_phi.R",  echo=knitr_debug, print.eval=TRUE)
@


\begin{table}[tb]
\centering
\caption{Compute time of results on the mice dataset. }
\begin{tabular}{|r|r|}
    \hline 
    & time (seconds) \\ 
    \hline 
    Initial fit & \Sexpr{sprintf('%1.2g', init_fit_time)} \\
    \hline 
    Hessian solve for $\alpha$ sensitivity & 
        \Sexpr{sprintf('%1.2g', alpha_hess_time)}\\
    Linear approx. $\eta^{lin}(\alpha)$ for $\alpha = 1$ & 
        \Sexpr{sprintf('%1.2g', lr_time_vec[1])}\\
    Linear approx. $\eta^{lin}(\alpha)$ for $\alpha = 11$ & 
        \Sexpr{sprintf('%1.2g', lr_time_vec[2])}\\
    Refit $\eta(\alpha)$ for $\alpha = 1$ & 
        \Sexpr{sprintf('%1.2g', refit_time_vec[1])}\\
    Refit $\eta(\alpha)$ for $\alpha = 11$ & 
        \Sexpr{sprintf('%1.2g', refit_time_vec[2])}\\
    \hline
    The influence function & \Sexpr{sprintf('%1.2g', infl_time)}\\ 
    Hessian solve for $\phi$ perturbation &
        \Sexpr{sprintf('%1.2g', phi_hessian_time)}\\
    Linear approx. $\eta^{lin}(\epsilon)$ at $\epsilon = 1$ &
        \Sexpr{sprintf('%1.2g', phi_lr_time)}\\
    Refit $\eta(\epsilon)$ at $\epsilon = 1$ &
        \Sexpr{sprintf('%1.2g', phi_refit_time)}\\
    \hline
\end{tabular}
\end{table}
